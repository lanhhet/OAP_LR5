
/* 
    Шейбак Дарья, гр3 курс 2, ИСИТ
   
    1) Определить иерархию и композицию классов (в соответствии с вариантом), реализовать классы. 
       Если необходимо расширьте по своему усмотрению иерархию для выполнения всех пунктов л.р. 
       Каждый класс должен иметь отражающее смысл название и информативный состав. 
       При кодировании должны быть использованы соглашения об оформлении кода code convention. 
       В одном из классов переопределите все методы, унаследованные от Object. 
    2) В проекте должен быть минимум один интерфейс и абстрактный класс. Использовать виртуальные методы и переопределение. 
    3) Сделайте один из классов sealed; 
    4) Добавьте в интерфейсы (интерфейс) и абстрактный класс одноименные методы. Например,
        interface ICloneable
        {
        bool DoClone();
        }
        abstract class BaseClone
        {
        public abstract bool DoClone();
        }
        class UserClass:BaseClone, ICloneable
        {
        ....
        } 
       Дайте в наследуемом классе им разную реализацию и вызовите эти методы. 
    5) Написать демонстрационную программу, в которой создаются объекты различных классов. Поработать с объектами через ссылки на абстрактные классы и интерфейсы. 
       В этом случае для идентификации типов объектов использовать операторы is или as. 
    6) Во всех классах (иерархии) переопределить метод ToString(), который выводит информацию о типе объекта и его текущих значениях. 
    7) Создайте дополнительный класс Printer c полиморфным методом IAmPrinting( SomeAbstractClassorInterface someobj). 
       Формальным параметром метода должна быть ссылка на абстрактный класс или наиболее общий интерфейс в вашей иерархии классов. 
       В методе iIAmPrinting определите тип объекта и вызовите ToString(). 
       В демонстрационной программе создайте массив, содержащий ссылки на разнотипные объекты ваших классов по иерархии, а также объект класса Printer и последовательно 
       вызовите его метод IAmPrinting со всеми ссылками в качестве аргументов. 

       Вариант 22 - перечень классов :
       Персона, Клиент, Адрес, Счет, Операции со счетом, Накопительный, Валютный, Расчетный, Общий, Карта дебетовая и т.д.
 
       Т Е О Р И Я :

       Иерархия фомируется наследованием. 
       Композицией же называют такое отношение между классами, при котором объекты одного являются неотъемлемой частью другого.

       Стили именования:

        Pascal case – первая буква каждого слова в имени идентификатора начинается с верхнего регистра (пример: TheCategory;)
        Camel case – первая буква первого слова в идентификаторе в нижнем регистре, все первые буквы последующих слов – в верхнем (пример: theCategory;)
        UpperCase – стиль используется только для сокращений, все буквы в имени идентификатора в верхнем регистре (пример: ID;)
        Hungarian notation – перед именем идентификатора пишется его тип в сокращенной форме (пример: strFirstName, iCurrentYear)
     
      Правила именования классов :

      - для классов используется стиль именования pascal case
      - в качестве имен классов используются имена существительные
      - имя класса не должно совпадать с именем namespace’а
      - следует избегать имен классов, совпадающих с именами классов .NET Framework
      - в качестве имен классов используются имена существительные
      - при создании классов потомков их имена состоят из имени базового класса и суффикса класса потомка, 
        если суффиксов несколько – они разделяются символом подчеркивания (пример: базовый класс Figure, потомок FigureCircle)
      - имена файлов, в которых находятся классы, совпадают с именами классов, для именования файлов используется стиль pascal case.

      Правила именования свойств     : для именования свойств используется стиль pascal case 
      Правила именования интерфейсов : имена интерфейсов начинаются с буквы I, после которой следует название интерфейса в pascal case (пример: IDisposable)
      Правила именования полей       : для именования полей, доступных вне класса, используется стиль pascal case, для private полей - camel case
      Правила именования переменных  : для именования переменных используется стиль camel case
      Правила именования констант    : для именования констант используется стиль pascal case
      
      Правила именования функций

      - для именования функций используется стиль pascal case
      - функции объявляются согласно следующему шаблону: <Модификатор доступа> [Другие модификаторы] <Тип> <Название функции>() (пример: protected abstract void HelloWorld())
      - для именования параметров функций используется стиль camel case

      Форматирование кода
      - используются стандартные настройки форматирования Visual Studio
      - в одном файле не объявляется больше одного namespace’а и одного класса (исключение – небольшие вспомогательные private классы)
      - фигурные скобки размещаются всегда на отдельной строке
      - каждая переменная объявляется на отдельной строке
      - все комментарии должны быть на русском языке


       Итак определим следующую иерархию и композицию классов - схема :
 
    [Персона]                                        Счет                                 Операции со счетом     Платежная карта
    ThePerson                                       Account                                   AccOpers              PayCard
        |                 ____________________________|____________________________                                    |
     Клиент  [  Адрес     Накопительный      Валютный      Расчетный          Общий                         Дебетовая      Кредитная     ]
   TheClient   Address  AccountCumulative AccountCurrency AccountSettlement AccountTotal                  PayCardDebet   PayCardCredit                                                                          
                                                                                                                             
                                                         
                                                   
 */


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {

            Console.WriteLine("\nОпределим объект класса");            
            TheClient NewBanksClient = new TheClient("Шейбак Дарья", 18, 'f',
                                                     "Минск", "Мирошниченко", 9, 202, 
                                                     "017496578246", 112.31, 12,
                                                     "057570295667", 6784, "GBP",
                                                     "2957905752097", 4325, "ЗАО Мирамакс", // пусть клиент еще и учредитель юр.лица
                                                     "2957905752097", 442424, 2,
                                                     "2342-45622-2535", "4244", 57,
                                                     "2480-242454-445", "3134", 2000
                                                     );
            NewBanksClient.GetInfo(); // вывод на консоль информации о клиенте

            Console.WriteLine("\nПроверим переопределение методов унаследованных от Object (переопределили в классе Account) ");
            Account SomeAcc1 = new Account("524556662", 3500);
            SomeAcc1.GetInfo();
            Account SomeAcc2 = new Account("524556662", 3500);
            SomeAcc2.GetInfo();
            if (SomeAcc1.Equals(SomeAcc2)) Console.WriteLine("Счета совпадают");
            else Console.WriteLine("Счета не совпадают");
            Console.WriteLine("Хеш счета : {0}", SomeAcc1.GetHashCode());
            Console.WriteLine("Именование объекта : {0}", SomeAcc1.GetType());

            Console.WriteLine("\nПроверим переопределение метода ToString() у классов иерархии");
            Console.WriteLine(NewBanksClient.ToString());

            Console.WriteLine("\nВызовем метод SayFio() одновременно объявленный в абстрактном базовом классе ThePerson и в интерфейсе IFio - сравним результат");
            Console.WriteLine(NewBanksClient.SayFio());
            Console.WriteLine(((IFio)NewBanksClient).SayFio());

            Console.WriteLine("\nОпределим объект Интерфейса");
            IFio NewBanksClient2 = new TheClient( "Эмилия Уотсон", 16, 'f',
                                                  "Минск", "Мястровская", 12, 69,
                                                  "017435255578246", 166.21, 14,
                                                  "057555255567", 6694, "EUR",
                                                  "2253552552097", 4795, "ЗАО Грацио", // пусть клиент еще и учредитель юр.лица
                                                  "2957905799797", 444244, 2,
                                                  "2342-45462-2645", "4244", 47,
                                                  "2411-241664-465", "3134", 4000
                                                  );

            Console.WriteLine("Выведем для объекта Интерфейса результат вызова SayFio() и ToString()");
            if (NewBanksClient2 is IFio) Console.WriteLine(NewBanksClient2.SayFio());
            if (NewBanksClient2 is IFio) Console.WriteLine((NewBanksClient2 as TheClient).ToString());

            Console.WriteLine("\nСоздадим массива ссылок на объекты, а также объект Printer с методом IAmPrinting(ThePerson someobj) и последовательно передадим в него члены массива\n");
            // массив ссылок на объекты
            ThePerson [] PersonArray = new ThePerson [2];
            PersonArray[0] = NewBanksClient;
            PersonArray[1] = (NewBanksClient2 as TheClient);
            Printer MyPrinter = new Printer();
            for (int i = 0; i < PersonArray.Length; i++) MyPrinter.IAmPrinting(PersonArray[i]);

            Console.ReadKey();
        }
    }
}
